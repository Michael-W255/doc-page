<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Vibe Trading Êï∞ÊçÆÁúãÊùø</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang SC', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
        }

        .header {
            text-align: center;
            padding: 30px 20px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 2.2em;
            font-weight: 600;
            background: linear-gradient(90deg, #00d4aa, #7b68ee, #f0b90b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .header p {
            color: #888;
            font-size: 0.95em;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #7b68ee;
        }

        .loading-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 3px solid rgba(123, 104, 238, 0.3);
            border-radius: 50%;
            border-top-color: #7b68ee;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .stat-card h3 {
            font-size: 0.85em;
            color: #888;
            margin-bottom: 8px;
            font-weight: 400;
        }

        .stat-card .value {
            font-size: 1.8em;
            font-weight: 700;
            color: #fff;
        }

        .stat-card .sub {
            font-size: 0.75em;
            color: #666;
            margin-top: 5px;
        }

        .stat-card.binance .value {
            color: #F0B90B;
        }

        .stat-card.okx .value {
            color: #fff;
        }

        .stat-card.bitmart .value {
            color: #00D4AA;
        }

        .stat-card.hyperliquid .value {
            color: #7B68EE;
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            padding: 20px;
            margin: 20px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .section-title {
            font-size: 1.3em;
            font-weight: 600;
            color: #fff;
            margin: 30px 20px 10px;
            padding-left: 15px;
            border-left: 4px solid #7b68ee;
        }

        .refresh-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: linear-gradient(135deg, #7b68ee, #00d4aa);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            box-shadow: 0 4px 15px rgba(123, 104, 238, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .refresh-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(123, 104, 238, 0.5);
        }

        .refresh-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .depth-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .depth-table th,
        .depth-table td {
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .depth-table th {
            color: #888;
            font-weight: 500;
            font-size: 0.9em;
        }

        .depth-table td {
            color: #fff;
        }

        .depth-table tr:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .rating-good {
            color: #00d4aa;
        }

        .rating-ok {
            color: #f0b90b;
        }

        .rating-bad {
            color: #ff6b6b;
        }

        footer {
            text-align: center;
            padding: 30px;
            color: #555;
            font-size: 0.85em;
        }

        footer a {
            color: #7b68ee;
            text-decoration: none;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>üìä Vibe Trading Êï∞ÊçÆÁúãÊùø</h1>
        <p id="timestamp">Âä†ËΩΩ‰∏≠...</p>
    </div>

    <div id="stats-container">
        <div class="loading">
            <div class="loading-spinner"></div>
            <p style="margin-top: 15px;">Ê≠£Âú®Ëé∑ÂèñÊúÄÊñ∞Êï∞ÊçÆ...</p>
        </div>
    </div>

    <div id="charts-container"></div>

    <button class="refresh-btn" onclick="refreshData()">üîÑ Âà∑Êñ∞Êï∞ÊçÆ</button>

    <footer>
        Êï∞ÊçÆÊù•Ê∫êÔºöBinance, OKX, BitMart, Hyperliquid API
    </footer>

    <script>
        const TIER_THRESHOLDS = [
            [1e9, "T1 ‚â•1B"], [3e8, "T2 300M‚Äì1B"], [1e8, "T3 100M‚Äì300M"],
            [3e7, "T4 30M‚Äì100M"], [1e7, "T5 10M‚Äì30M"], [3e6, "T6 3M‚Äì10M"],
            [1e6, "T7 1M‚Äì3M"], [3e5, "T8 300k‚Äì1M"], [1e5, "T9 100k‚Äì300k"], [0, "T10 <100k"],
        ];

        const COLORS = {
            "Binance": "#F0B90B", "OKX": "#ffffff",
            "BitMart": "#00D4AA", "Hyperliquid": "#7B68EE",
        };

        const CORS_PROXY = "https://api.allorigins.win/raw?url=";

        function getTier(volume) {
            for (const [threshold, tierName] of TIER_THRESHOLDS) {
                if (volume >= threshold) return tierName;
            }
            return "T10 <100k";
        }

        function formatVolume(num) {
            if (num >= 1e9) return (num / 1e9).toFixed(2) + "B";
            if (num >= 1e6) return (num / 1e6).toFixed(2) + "M";
            if (num >= 1e3) return (num / 1e3).toFixed(2) + "K";
            return num.toFixed(0);
        }

        async function fetchWithProxy(url, options = {}) {
            try {
                const resp = await fetch(url, { ...options, mode: 'cors' });
                if (resp.ok) return resp;
            } catch (e) { }
            return fetch(CORS_PROXY + encodeURIComponent(url), options);
        }

        // ========== Êï∞ÊçÆËé∑Âèñ ==========

        async function fetchBinanceSpot() {
            try {
                const resp = await fetch("https://api.binance.com/api/v3/ticker/24hr");
                const data = await resp.json();
                return data.filter(item => item.symbol.endsWith("USDT"))
                    .map(item => ({ symbol: item.symbol, base: item.symbol.slice(0, -4), volume: parseFloat(item.quoteVolume) || 0 }));
            } catch (e) { return []; }
        }

        async function fetchBinanceFutures() {
            try {
                const resp = await fetch("https://fapi.binance.com/fapi/v1/ticker/24hr");
                const data = await resp.json();
                return data.filter(item => item.symbol.endsWith("USDT"))
                    .map(item => ({ symbol: item.symbol, base: item.symbol.slice(0, -4), volume: parseFloat(item.quoteVolume) || 0 }));
            } catch (e) { return []; }
        }

        async function fetchOKXSpot() {
            try {
                const resp = await fetchWithProxy("https://www.okx.com/api/v5/market/tickers?instType=SPOT");
                const json = await resp.json();
                return (json.data || []).filter(item => item.instId.endsWith("-USDT"))
                    .map(item => ({ symbol: item.instId, base: item.instId.split("-")[0], volume: parseFloat(item.volCcy24h) || 0 }));
            } catch (e) { return []; }
        }

        async function fetchOKXSwap() {
            try {
                const resp = await fetchWithProxy("https://www.okx.com/api/v5/market/tickers?instType=SWAP");
                const json = await resp.json();
                return (json.data || []).filter(item => item.instId.includes("-USDT-SWAP"))
                    .map(item => ({ symbol: item.instId, base: item.instId.split("-")[0], volume: (parseFloat(item.volCcy24h) || 0) * (parseFloat(item.last) || 0) }));
            } catch (e) { return []; }
        }

        async function fetchBitMartSpot() {
            try {
                const resp = await fetchWithProxy("https://api-cloud.bitmart.com/spot/quotation/v3/tickers");
                const json = await resp.json();
                return (json.data || []).filter(item => Array.isArray(item) && item[0].endsWith("_USDT"))
                    .map(item => ({ symbol: item[0], base: item[0].slice(0, -5).replace(/^\$/, ""), volume: parseFloat(item[3]) || 0 }));
            } catch (e) { return []; }
        }

        async function fetchBitMartFutures() {
            try {
                const resp = await fetchWithProxy("https://contract-v2.bitmart.com/v1/ifcontract/tickers");
                const json = await resp.json();
                const tickers = json.data?.tickers || [];
                return tickers.filter(item => item.contract_name?.endsWith("USDT"))
                    .map(item => ({ symbol: item.contract_name, base: item.contract_name.slice(0, -4), volume: parseFloat(item.amount24) || 0 }));
            } catch (e) { return []; }
        }

        async function fetchHyperliquidPerps() {
            try {
                const resp = await fetch("https://api.hyperliquid.xyz/info", {
                    method: "POST", headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ type: "metaAndAssetCtxs" })
                });
                const data = await resp.json();
                const universe = data[0]?.universe || [];
                const assetCtxs = data[1] || [];
                return universe.map((asset, i) => ({ symbol: asset.name, base: asset.name, volume: parseFloat(assetCtxs[i]?.dayNtlVlm) || 0 }));
            } catch (e) { return []; }
        }

        async function fetchHyperliquidSpot() {
            try {
                const resp = await fetch("https://api.hyperliquid.xyz/info", {
                    method: "POST", headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ type: "spotMetaAndAssetCtxs" })
                });
                const data = await resp.json();
                if (!data || data.length < 2) return [];
                const tokens = data[0]?.tokens || [];
                const assetCtxs = data[1] || [];
                return assetCtxs.map((ctx, i) => ({ symbol: tokens[i]?.name || `TOKEN${i}`, base: tokens[i]?.name || `TOKEN${i}`, volume: parseFloat(ctx.dayNtlVlm) || 0 }));
            } catch (e) { return []; }
        }

        // Ëé∑Âèñ 7 Â§© K Á∫øÊï∞ÊçÆ
        async function fetch7DayKlines(symbol, exchange) {
            try {
                if (exchange === "Binance") {
                    const resp = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}USDT&interval=1d&limit=7`);
                    const data = await resp.json();
                    return data.map(k => ({ date: new Date(k[0]).toLocaleDateString(), volume: parseFloat(k[7]) || 0 }));
                } else if (exchange === "OKX") {
                    const resp = await fetchWithProxy(`https://www.okx.com/api/v5/market/candles?instId=${symbol}-USDT-SWAP&bar=1D&limit=7`);
                    const json = await resp.json();
                    return (json.data || []).reverse().map(k => ({ date: new Date(parseInt(k[0])).toLocaleDateString(), volume: parseFloat(k[5]) * parseFloat(k[4]) || 0 }));
                }
            } catch (e) { return []; }
            return [];
        }

        // Ëé∑ÂèñÊ∑±Â∫¶Êï∞ÊçÆ
        async function fetchDepth(symbol, exchange) {
            try {
                if (exchange === "Binance") {
                    const resp = await fetch(`https://fapi.binance.com/fapi/v1/depth?symbol=${symbol}USDT&limit=20`);
                    const data = await resp.json();
                    return calculateDepthMetrics(data.bids, data.asks);
                } else if (exchange === "OKX") {
                    const resp = await fetchWithProxy(`https://www.okx.com/api/v5/market/books?instId=${symbol}-USDT-SWAP&sz=20`);
                    const json = await resp.json();
                    const book = json.data?.[0] || {};
                    return calculateDepthMetrics(book.bids, book.asks);
                } else if (exchange === "Hyperliquid") {
                    const resp = await fetch("https://api.hyperliquid.xyz/info", {
                        method: "POST", headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ type: "l2Book", coin: symbol })
                    });
                    const data = await resp.json();
                    return calculateDepthMetrics(data.levels?.[0] || [], data.levels?.[1] || []);
                }
            } catch (e) { }
            return { spread: 0, depth2pct: 0, top10: 0 };
        }

        function calculateDepthMetrics(bids, asks) {
            if (!bids?.length || !asks?.length) return { spread: 0, depth2pct: 0, top10: 0 };

            const bid1 = parseFloat(bids[0][0]);
            const ask1 = parseFloat(asks[0][0]);
            const mid = (bid1 + ask1) / 2;
            const spread = ((ask1 - bid1) / mid * 10000).toFixed(1);

            let depth2pct = 0;
            const lowerBound = mid * 0.98;
            const upperBound = mid * 1.02;

            for (const [price, qty] of bids) {
                if (parseFloat(price) >= lowerBound) depth2pct += parseFloat(price) * parseFloat(qty);
            }
            for (const [price, qty] of asks) {
                if (parseFloat(price) <= upperBound) depth2pct += parseFloat(price) * parseFloat(qty);
            }

            let top10 = 0;
            for (let i = 0; i < Math.min(10, bids.length); i++) {
                top10 += parseFloat(bids[i][0]) * parseFloat(bids[i][1]);
            }
            for (let i = 0; i < Math.min(10, asks.length); i++) {
                top10 += parseFloat(asks[i][0]) * parseFloat(asks[i][1]);
            }

            return { spread, depth2pct, top10 };
        }

        // ========== Êï∞ÊçÆÂ§ÑÁêÜ ==========

        function calculateTierDistribution(tickers) {
            const counts = {};
            TIER_THRESHOLDS.forEach(([, name]) => counts[name] = 0);
            tickers.forEach(t => counts[getTier(t.volume)]++);
            return counts;
        }

        // ========== ÂõæË°®ÁîüÊàê ==========

        function createCoinCountChart(spotData, futuresData) {
            const exchanges = Object.keys(spotData);
            return {
                data: [
                    { name: "Áé∞Ë¥ß", x: exchanges, y: exchanges.map(e => spotData[e].length), type: "bar", marker: { color: "#4CAF50" } },
                    { name: "ÂêàÁ∫¶", x: exchanges, y: exchanges.map(e => futuresData[e]?.length || 0), type: "bar", marker: { color: "#2196F3" } }
                ],
                layout: {
                    title: { text: "ÂêÑ‰∫§ÊòìÊâÄÂ∏ÅÁßçÊï∞ÈáèÂØπÊØî", font: { color: "#fff" } },
                    barmode: "group", height: 400,
                    paper_bgcolor: "rgba(0,0,0,0)", plot_bgcolor: "rgba(255,255,255,0.02)",
                    font: { color: "#888" },
                    xaxis: { gridcolor: "rgba(255,255,255,0.05)" },
                    yaxis: { gridcolor: "rgba(255,255,255,0.05)", title: "Â∏ÅÁßçÊï∞Èáè" },
                    legend: { font: { color: "#ccc" } }
                }
            };
        }

        function createTierChart(spotData, futuresData) {
            const tierOrder = TIER_THRESHOLDS.map(t => t[1]);
            const traces = [];

            for (const [exchange, tickers] of Object.entries(spotData)) {
                const dist = calculateTierDistribution(tickers);
                traces.push({
                    name: `${exchange} Áé∞Ë¥ß`, x: tierOrder, y: tierOrder.map(t => dist[t] || 0),
                    type: "bar", marker: { color: COLORS[exchange] }, xaxis: "x", yaxis: "y",
                });
            }
            for (const [exchange, tickers] of Object.entries(futuresData)) {
                const dist = calculateTierDistribution(tickers);
                traces.push({
                    name: `${exchange} ÂêàÁ∫¶`, x: tierOrder, y: tierOrder.map(t => dist[t] || 0),
                    type: "bar", marker: { color: COLORS[exchange] }, xaxis: "x2", yaxis: "y2", showlegend: false,
                });
            }

            return {
                data: traces,
                layout: {
                    title: { text: "Tier ÂàÜÂ∏ÉÂØπÊØîÔºàÊåâ 24h Êàê‰∫§È¢ùÂàÜÂ±ÇÔºâ", font: { color: "#fff" } },
                    barmode: "group", height: 450,
                    paper_bgcolor: "rgba(0,0,0,0)", plot_bgcolor: "rgba(255,255,255,0.02)",
                    font: { color: "#888" },
                    legend: { orientation: "h", y: 1.12, font: { color: "#ccc" } },
                    grid: { rows: 1, columns: 2, pattern: "independent" },
                    xaxis: { domain: [0, 0.48], gridcolor: "rgba(255,255,255,0.05)" },
                    yaxis: { gridcolor: "rgba(255,255,255,0.05)" },
                    xaxis2: { domain: [0.52, 1], gridcolor: "rgba(255,255,255,0.05)" },
                    yaxis2: { gridcolor: "rgba(255,255,255,0.05)" },
                    annotations: [
                        { text: "Áé∞Ë¥ß", x: 0.24, y: 1.05, xref: "paper", yref: "paper", showarrow: false, font: { color: "#aaa", size: 14 } },
                        { text: "ÂêàÁ∫¶", x: 0.76, y: 1.05, xref: "paper", yref: "paper", showarrow: false, font: { color: "#aaa", size: 14 } },
                    ],
                },
            };
        }

        function createVolumeChart(spotData, futuresData) {
            const spotVolumes = Object.entries(spotData).map(([name, tickers]) => ({
                name, volume: tickers.reduce((sum, t) => sum + t.volume, 0)
            }));
            const futuresVolumes = Object.entries(futuresData).map(([name, tickers]) => ({
                name, volume: tickers.reduce((sum, t) => sum + t.volume, 0)
            }));

            return {
                data: [
                    {
                        labels: spotVolumes.map(d => d.name), values: spotVolumes.map(d => d.volume),
                        type: "pie", hole: 0.4, marker: { colors: spotVolumes.map(d => COLORS[d.name]) },
                        domain: { x: [0, 0.45] }, textinfo: "label+percent", textfont: { color: "#fff" },
                    },
                    {
                        labels: futuresVolumes.map(d => d.name), values: futuresVolumes.map(d => d.volume),
                        type: "pie", hole: 0.4, marker: { colors: futuresVolumes.map(d => COLORS[d.name]) },
                        domain: { x: [0.55, 1] }, textinfo: "label+percent", textfont: { color: "#fff" },
                    }
                ],
                layout: {
                    title: { text: "24h Êàê‰∫§È¢ùÂç†ÊØî", font: { color: "#fff" } },
                    height: 400, paper_bgcolor: "rgba(0,0,0,0)", font: { color: "#888" }, showlegend: false,
                    annotations: [
                        { text: "Áé∞Ë¥ß", x: 0.18, y: 0.5, font: { size: 16, color: "#aaa" }, showarrow: false },
                        { text: "ÂêàÁ∫¶", x: 0.82, y: 0.5, font: { size: 16, color: "#aaa" }, showarrow: false },
                    ],
                },
            };
        }

        function create24hVs7dChart(futuresData, klineData) {
            // ËÆ°ÁÆó 24h Êàê‰∫§È¢ù
            const exchanges = Object.keys(futuresData);
            const vol24h = exchanges.map(e => futuresData[e].reduce((sum, t) => sum + t.volume, 0) / 1e9);

            // ËÆ°ÁÆó 7d Êó•ÂùáÊàê‰∫§È¢ùÔºà‰ªé BTC+ETH+SOL ÁöÑ K Á∫øÊï∞ÊçÆ‰º∞ÁÆóÊï¥‰ΩìÔºâ
            const vol7dDaily = exchanges.map(e => {
                let total7d = 0;
                for (const symbol of ["BTC", "ETH", "SOL"]) {
                    const data = klineData[symbol]?.[e] || [];
                    total7d += data.reduce((sum, d) => sum + d.volume, 0);
                }
                // ‰∏ªÊµÅÂ∏ÅÂç†ÊØîÁ∫¶ 60%ÔºåÂèçÊé®ÊÄªÈáè
                return total7d / 7 / 0.6 / 1e9;
            });

            return {
                data: [
                    {
                        name: "24h Êàê‰∫§È¢ù",
                        x: exchanges,
                        y: vol24h,
                        type: "bar",
                        marker: { color: "#7B68EE" },
                    },
                    {
                        name: "7d Êó•ÂùáÊàê‰∫§È¢ù",
                        x: exchanges,
                        y: vol7dDaily,
                        type: "bar",
                        marker: { color: "#00D4AA" },
                    }
                ],
                layout: {
                    title: { text: "24h vs 7d Êó•ÂùáÊàê‰∫§È¢ùÂØπÊØîÔºàÂêàÁ∫¶ÔºåÂçï‰ΩçÔºöB USDTÔºâ", font: { color: "#fff" } },
                    barmode: "group",
                    height: 400,
                    paper_bgcolor: "rgba(0,0,0,0)", plot_bgcolor: "rgba(255,255,255,0.02)",
                    font: { color: "#888" },
                    xaxis: { gridcolor: "rgba(255,255,255,0.05)" },
                    yaxis: { gridcolor: "rgba(255,255,255,0.05)", title: "Êàê‰∫§È¢ù (B)" },
                    legend: { font: { color: "#ccc" }, orientation: "h", y: 1.1 },
                },
            };
        }

        function create7DayTrendChart(klineData) {
            const traces = [];

            for (const [symbol, exchanges] of Object.entries(klineData)) {
                for (const [exchange, data] of Object.entries(exchanges)) {
                    if (data.length > 0) {
                        traces.push({
                            name: `${symbol} (${exchange})`,
                            x: data.map(d => d.date),
                            y: data.map(d => d.volume / 1e9),
                            type: "scatter",
                            mode: "lines+markers",
                            line: { width: 2 },
                            marker: { size: 6 },
                        });
                    }
                }
            }

            return {
                data: traces,
                layout: {
                    title: { text: "7 Â§©Êàê‰∫§È¢ùË∂ãÂäøÔºàBTC/ETH/SOL ÂêàÁ∫¶Ôºâ", font: { color: "#fff" } },
                    height: 400,
                    paper_bgcolor: "rgba(0,0,0,0)", plot_bgcolor: "rgba(255,255,255,0.02)",
                    font: { color: "#888" },
                    xaxis: { gridcolor: "rgba(255,255,255,0.05)" },
                    yaxis: { gridcolor: "rgba(255,255,255,0.05)", title: "Êàê‰∫§È¢ù (B)" },
                    legend: { font: { color: "#ccc" } },
                },
            };
        }

        function createDepthTable(depthData) {
            let html = `
        <div class="section-title">‰∫§ÊòìÊ∑±Â∫¶ÊåáÊ†áÔºàÂêàÁ∫¶Ôºâ</div>
        <div class="chart-container">
            <table class="depth-table">
                <thead>
                    <tr>
                        <th>Â∏ÅÁßç</th>
                        <th>‰∫§ÊòìÊâÄ</th>
                        <th>Bid-Ask Spread (bps)</th>
                        <th>¬±2% Ê∑±Â∫¶ (USDT)</th>
                        <th>Top10 Ê°£ (USDT)</th>
                        <th>ËØÑÁ∫ß</th>
                    </tr>
                </thead>
                <tbody>
    `;

            for (const [symbol, exchanges] of Object.entries(depthData)) {
                for (const [exchange, metrics] of Object.entries(exchanges)) {
                    const rating = metrics.spread < 5 ? "‰ºòÁßÄ" : metrics.spread < 20 ? "ËâØÂ•Ω" : "‰∏ÄËà¨";
                    const ratingClass = metrics.spread < 5 ? "rating-good" : metrics.spread < 20 ? "rating-ok" : "rating-bad";
                    html += `
                <tr>
                    <td><strong>${symbol}</strong></td>
                    <td>${exchange}</td>
                    <td>${metrics.spread}</td>
                    <td>${formatVolume(metrics.depth2pct)}</td>
                    <td>${formatVolume(metrics.top10)}</td>
                    <td class="${ratingClass}">${rating}</td>
                </tr>
            `;
                }
            }

            html += `</tbody></table></div>`;
            return html;
        }

        // ========== ‰∏ªÂáΩÊï∞ ==========

        let isLoading = false;

        async function refreshData() {
            if (isLoading) return;
            isLoading = true;

            const btn = document.querySelector(".refresh-btn");
            btn.disabled = true;
            btn.textContent = "‚è≥ Âä†ËΩΩ‰∏≠...";

            document.getElementById("stats-container").innerHTML = `
        <div class="loading">
            <div class="loading-spinner"></div>
            <p style="margin-top: 15px;">Ê≠£Âú®Ëé∑ÂèñÊúÄÊñ∞Êï∞ÊçÆ...</p>
        </div>
    `;
            document.getElementById("charts-container").innerHTML = "";

            try {
                // Âπ∂Ë°åËé∑ÂèñÂü∫Á°ÄÊï∞ÊçÆ
                const [binanceSpot, binanceFutures, okxSpot, okxSwap, bitmartSpot, bitmartFutures, hlSpot, hlPerps] = await Promise.all([
                    fetchBinanceSpot(), fetchBinanceFutures(), fetchOKXSpot(), fetchOKXSwap(),
                    fetchBitMartSpot(), fetchBitMartFutures(), fetchHyperliquidSpot(), fetchHyperliquidPerps(),
                ]);

                const spotData = { Binance: binanceSpot, OKX: okxSpot, BitMart: bitmartSpot, Hyperliquid: hlSpot };
                const futuresData = { Binance: binanceFutures, OKX: okxSwap, BitMart: bitmartFutures, Hyperliquid: hlPerps };

                // ÈöêËóèÂä†ËΩΩÊèêÁ§∫
                document.getElementById("stats-container").innerHTML = "";

                // ÁîüÊàêÂõæË°®
                const charts = [
                    createTierChart(spotData, futuresData),
                    createVolumeChart(spotData, futuresData),
                ];

                let chartsHtml = charts.map((_, i) => `<div class="chart-container"><div id="chart_${i}"></div></div>`).join("");

                document.getElementById("charts-container").innerHTML = chartsHtml;

                // Ê∏≤ÊüìÂõæË°®
                charts.forEach((chart, i) => {
                    Plotly.newPlot(`chart_${i}`, chart.data, chart.layout, { responsive: true });
                });

                document.getElementById("timestamp").textContent = `Êï∞ÊçÆÊõ¥Êñ∞Êó∂Èó¥: ${new Date().toLocaleString("zh-CN")}`;

            } catch (e) {
                console.error("Error:", e);
                document.getElementById("stats-container").innerHTML = `
            <div style="color:#ff6b6b;padding:20px;text-align:center;">Êï∞ÊçÆÂä†ËΩΩÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï</div>
        `;
            }

            btn.disabled = false;
            btn.textContent = "üîÑ Âà∑Êñ∞Êï∞ÊçÆ";
            isLoading = false;
        }

        document.addEventListener("DOMContentLoaded", refreshData);
    </script>
</body>

</html>