<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Vibe Trading æ•°æ®çœ‹æ¿</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang SC', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
        }
        .header {
            text-align: center;
            padding: 30px 20px;
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .header h1 {
            font-size: 2.2em;
            font-weight: 600;
            background: linear-gradient(90deg, #00d4aa, #7b68ee, #f0b90b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        .header p { color: #888; font-size: 0.95em; }
        .loading { text-align: center; padding: 40px; color: #7b68ee; }
        .loading-spinner {
            display: inline-block; width: 40px; height: 40px;
            border: 3px solid rgba(123, 104, 238, 0.3);
            border-radius: 50%; border-top-color: #7b68ee;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px; padding: 20px; max-width: 1400px; margin: 0 auto;
        }
        .stat-card {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            border-radius: 12px; padding: 20px; text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .stat-card:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(0,0,0,0.3); }
        .stat-card h3 { font-size: 0.85em; color: #888; margin-bottom: 8px; font-weight: 400; }
        .stat-card .value { font-size: 1.8em; font-weight: 700; color: #fff; }
        .stat-card .sub { font-size: 0.75em; color: #666; margin-top: 5px; }
        .stat-card.binance .value { color: #F0B90B; }
        .stat-card.okx .value { color: #fff; }
        .stat-card.bitmart .value { color: #00D4AA; }
        .stat-card.hyperliquid .value { color: #7B68EE; }
        .chart-container {
            background: rgba(255,255,255,0.03);
            border-radius: 12px; padding: 20px; margin: 20px;
            border: 1px solid rgba(255,255,255,0.08);
        }
        .section-title {
            font-size: 1.3em; font-weight: 600; color: #fff;
            margin: 30px 20px 10px; padding-left: 15px;
            border-left: 4px solid #7b68ee;
        }
        .refresh-btn {
            position: fixed; bottom: 30px; right: 30px;
            background: linear-gradient(135deg, #7b68ee, #00d4aa);
            color: white; border: none; padding: 15px 25px;
            border-radius: 30px; cursor: pointer; font-size: 1em; font-weight: 500;
            box-shadow: 0 4px 15px rgba(123, 104, 238, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .refresh-btn:hover { transform: scale(1.05); box-shadow: 0 6px 20px rgba(123, 104, 238, 0.5); }
        .refresh-btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .depth-table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        .depth-table th, .depth-table td {
            padding: 12px; text-align: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .depth-table th { color: #888; font-weight: 500; font-size: 0.9em; }
        .depth-table td { color: #fff; }
        .depth-table tr:hover { background: rgba(255,255,255,0.03); }
        .rating-good { color: #00d4aa; }
        .rating-ok { color: #f0b90b; }
        .rating-bad { color: #ff6b6b; }
        footer { text-align: center; padding: 30px; color: #555; font-size: 0.85em; }
        footer a { color: #7b68ee; text-decoration: none; }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ“Š Vibe Trading æ•°æ®çœ‹æ¿</h1>
        <p id="timestamp">åŠ è½½ä¸­...</p>
    </div>
    
    <div id="stats-container">
        <div class="loading">
            <div class="loading-spinner"></div>
            <p style="margin-top: 15px;">æ­£åœ¨è·å–æœ€æ–°æ•°æ®...</p>
        </div>
    </div>
    
    <div id="charts-container"></div>
    
    <button class="refresh-btn" onclick="refreshData()">ğŸ”„ åˆ·æ–°æ•°æ®</button>
    
    <footer>
        æ•°æ®æ¥æºï¼šBinance, OKX, BitMart, Hyperliquid API
    </footer>

<script>
const TIER_THRESHOLDS = [
    [1e9, "T1 â‰¥1B"], [3e8, "T2 300Mâ€“1B"], [1e8, "T3 100Mâ€“300M"],
    [3e7, "T4 30Mâ€“100M"], [1e7, "T5 10Mâ€“30M"], [3e6, "T6 3Mâ€“10M"],
    [1e6, "T7 1Mâ€“3M"], [3e5, "T8 300kâ€“1M"], [1e5, "T9 100kâ€“300k"], [0, "T10 <100k"],
];

const COLORS = {
    "Binance": "#F0B90B", "OKX": "#ffffff",
    "BitMart": "#00D4AA", "Hyperliquid": "#7B68EE",
};

const CORS_PROXY = "https://api.allorigins.win/raw?url=";

function getTier(volume) {
    for (const [threshold, tierName] of TIER_THRESHOLDS) {
        if (volume >= threshold) return tierName;
    }
    return "T10 <100k";
}

function formatVolume(num) {
    if (num >= 1e9) return (num / 1e9).toFixed(2) + "B";
    if (num >= 1e6) return (num / 1e6).toFixed(2) + "M";
    if (num >= 1e3) return (num / 1e3).toFixed(2) + "K";
    return num.toFixed(0);
}

async function fetchWithProxy(url, options = {}) {
    try {
        const resp = await fetch(url, { ...options, mode: 'cors' });
        if (resp.ok) return resp;
    } catch (e) {}
    return fetch(CORS_PROXY + encodeURIComponent(url), options);
}

// ========== æ•°æ®è·å– ==========

async function fetchBinanceSpot() {
    try {
        const resp = await fetch("https://api.binance.com/api/v3/ticker/24hr");
        const data = await resp.json();
        return data.filter(item => item.symbol.endsWith("USDT"))
            .map(item => ({ symbol: item.symbol, base: item.symbol.slice(0, -4), volume: parseFloat(item.quoteVolume) || 0 }));
    } catch (e) { return []; }
}

async function fetchBinanceFutures() {
    try {
        const resp = await fetch("https://fapi.binance.com/fapi/v1/ticker/24hr");
        const data = await resp.json();
        return data.filter(item => item.symbol.endsWith("USDT"))
            .map(item => ({ symbol: item.symbol, base: item.symbol.slice(0, -4), volume: parseFloat(item.quoteVolume) || 0 }));
    } catch (e) { return []; }
}

async function fetchOKXSpot() {
    try {
        const resp = await fetchWithProxy("https://www.okx.com/api/v5/market/tickers?instType=SPOT");
        const json = await resp.json();
        return (json.data || []).filter(item => item.instId.endsWith("-USDT"))
            .map(item => ({ symbol: item.instId, base: item.instId.split("-")[0], volume: parseFloat(item.volCcy24h) || 0 }));
    } catch (e) { return []; }
}

async function fetchOKXSwap() {
    try {
        const resp = await fetchWithProxy("https://www.okx.com/api/v5/market/tickers?instType=SWAP");
        const json = await resp.json();
        return (json.data || []).filter(item => item.instId.includes("-USDT-SWAP"))
            .map(item => ({ symbol: item.instId, base: item.instId.split("-")[0], volume: (parseFloat(item.volCcy24h) || 0) * (parseFloat(item.last) || 0) }));
    } catch (e) { return []; }
}

async function fetchBitMartSpot() {
    try {
        const resp = await fetchWithProxy("https://api-cloud.bitmart.com/spot/quotation/v3/tickers");
        const json = await resp.json();
        return (json.data || []).filter(item => Array.isArray(item) && item[0].endsWith("_USDT"))
            .map(item => ({ symbol: item[0], base: item[0].slice(0, -5).replace(/^\$/, ""), volume: parseFloat(item[3]) || 0 }));
    } catch (e) { return []; }
}

async function fetchBitMartFutures() {
    try {
        const resp = await fetchWithProxy("https://contract-v2.bitmart.com/v1/ifcontract/tickers");
        const json = await resp.json();
        const tickers = json.data?.tickers || [];
        return tickers.filter(item => item.contract_name?.endsWith("USDT"))
            .map(item => ({ symbol: item.contract_name, base: item.contract_name.slice(0, -4), volume: parseFloat(item.amount24) || 0 }));
    } catch (e) { return []; }
}

async function fetchHyperliquidPerps() {
    try {
        const resp = await fetch("https://api.hyperliquid.xyz/info", {
            method: "POST", headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ type: "metaAndAssetCtxs" })
        });
        const data = await resp.json();
        const universe = data[0]?.universe || [];
        const assetCtxs = data[1] || [];
        return universe.map((asset, i) => ({ symbol: asset.name, base: asset.name, volume: parseFloat(assetCtxs[i]?.dayNtlVlm) || 0 }));
    } catch (e) { return []; }
}

async function fetchHyperliquidSpot() {
    try {
        const resp = await fetch("https://api.hyperliquid.xyz/info", {
            method: "POST", headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ type: "spotMetaAndAssetCtxs" })
        });
        const data = await resp.json();
        if (!data || data.length < 2) return [];
        const tokens = data[0]?.tokens || [];
        const assetCtxs = data[1] || [];
        return assetCtxs.map((ctx, i) => ({ symbol: tokens[i]?.name || `TOKEN${i}`, base: tokens[i]?.name || `TOKEN${i}`, volume: parseFloat(ctx.dayNtlVlm) || 0 }));
    } catch (e) { return []; }
}

// è·å– 7 å¤© K çº¿æ•°æ®
async function fetch7DayKlines(symbol, exchange) {
    try {
        if (exchange === "Binance") {
            const resp = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}USDT&interval=1d&limit=7`);
            const data = await resp.json();
            return data.map(k => ({ date: new Date(k[0]).toLocaleDateString(), volume: parseFloat(k[7]) || 0 }));
        } else if (exchange === "OKX") {
            const resp = await fetchWithProxy(`https://www.okx.com/api/v5/market/candles?instId=${symbol}-USDT-SWAP&bar=1D&limit=7`);
            const json = await resp.json();
            return (json.data || []).reverse().map(k => ({ date: new Date(parseInt(k[0])).toLocaleDateString(), volume: parseFloat(k[5]) * parseFloat(k[4]) || 0 }));
        }
    } catch (e) { return []; }
    return [];
}

// è·å–æ·±åº¦æ•°æ®
async function fetchDepth(symbol, exchange) {
    try {
        if (exchange === "Binance") {
            const resp = await fetch(`https://fapi.binance.com/fapi/v1/depth?symbol=${symbol}USDT&limit=20`);
            const data = await resp.json();
            return calculateDepthMetrics(data.bids, data.asks);
        } else if (exchange === "OKX") {
            const resp = await fetchWithProxy(`https://www.okx.com/api/v5/market/books?instId=${symbol}-USDT-SWAP&sz=20`);
            const json = await resp.json();
            const book = json.data?.[0] || {};
            return calculateDepthMetrics(book.bids, book.asks);
        } else if (exchange === "Hyperliquid") {
            const resp = await fetch("https://api.hyperliquid.xyz/info", {
                method: "POST", headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ type: "l2Book", coin: symbol })
            });
            const data = await resp.json();
            return calculateDepthMetrics(data.levels?.[0] || [], data.levels?.[1] || []);
        }
    } catch (e) {}
    return { spread: 0, depth2pct: 0, top10: 0 };
}

function calculateDepthMetrics(bids, asks) {
    if (!bids?.length || !asks?.length) return { spread: 0, depth2pct: 0, top10: 0 };
    
    const bid1 = parseFloat(bids[0][0]);
    const ask1 = parseFloat(asks[0][0]);
    const mid = (bid1 + ask1) / 2;
    const spread = ((ask1 - bid1) / mid * 10000).toFixed(1);
    
    let depth2pct = 0;
    const lowerBound = mid * 0.98;
    const upperBound = mid * 1.02;
    
    for (const [price, qty] of bids) {
        if (parseFloat(price) >= lowerBound) depth2pct += parseFloat(price) * parseFloat(qty);
    }
    for (const [price, qty] of asks) {
        if (parseFloat(price) <= upperBound) depth2pct += parseFloat(price) * parseFloat(qty);
    }
    
    let top10 = 0;
    for (let i = 0; i < Math.min(10, bids.length); i++) {
        top10 += parseFloat(bids[i][0]) * parseFloat(bids[i][1]);
    }
    for (let i = 0; i < Math.min(10, asks.length); i++) {
        top10 += parseFloat(asks[i][0]) * parseFloat(asks[i][1]);
    }
    
    return { spread, depth2pct, top10 };
}

// ========== æ•°æ®å¤„ç† ==========

function calculateTierDistribution(tickers) {
    const counts = {};
    TIER_THRESHOLDS.forEach(([, name]) => counts[name] = 0);
    tickers.forEach(t => counts[getTier(t.volume)]++);
    return counts;
}

// ========== å›¾è¡¨ç”Ÿæˆ ==========

function createCoinCountChart(spotData, futuresData) {
    const exchanges = Object.keys(spotData);
    return {
        data: [
            { name: "ç°è´§", x: exchanges, y: exchanges.map(e => spotData[e].length), type: "bar", marker: { color: "#4CAF50" } },
            { name: "åˆçº¦", x: exchanges, y: exchanges.map(e => futuresData[e]?.length || 0), type: "bar", marker: { color: "#2196F3" } }
        ],
        layout: {
            title: { text: "å„äº¤æ˜“æ‰€å¸ç§æ•°é‡å¯¹æ¯”", font: { color: "#fff" } },
            barmode: "group", height: 400,
            paper_bgcolor: "rgba(0,0,0,0)", plot_bgcolor: "rgba(255,255,255,0.02)",
            font: { color: "#888" },
            xaxis: { gridcolor: "rgba(255,255,255,0.05)" },
            yaxis: { gridcolor: "rgba(255,255,255,0.05)", title: "å¸ç§æ•°é‡" },
            legend: { font: { color: "#ccc" } }
        }
    };
}

function createTierChart(spotData, futuresData) {
    const tierOrder = TIER_THRESHOLDS.map(t => t[1]);
    const traces = [];
    
    for (const [exchange, tickers] of Object.entries(spotData)) {
        const dist = calculateTierDistribution(tickers);
        traces.push({
            name: `${exchange} ç°è´§`, x: tierOrder, y: tierOrder.map(t => dist[t] || 0),
            type: "bar", marker: { color: COLORS[exchange] }, xaxis: "x", yaxis: "y",
        });
    }
    for (const [exchange, tickers] of Object.entries(futuresData)) {
        const dist = calculateTierDistribution(tickers);
        traces.push({
            name: `${exchange} åˆçº¦`, x: tierOrder, y: tierOrder.map(t => dist[t] || 0),
            type: "bar", marker: { color: COLORS[exchange] }, xaxis: "x2", yaxis: "y2", showlegend: false,
        });
    }
    
    return {
        data: traces,
        layout: {
            title: { text: "Tier åˆ†å¸ƒå¯¹æ¯”ï¼ˆæŒ‰ 24h æˆäº¤é¢åˆ†å±‚ï¼‰", font: { color: "#fff" } },
            barmode: "group", height: 450,
            paper_bgcolor: "rgba(0,0,0,0)", plot_bgcolor: "rgba(255,255,255,0.02)",
            font: { color: "#888" },
            legend: { orientation: "h", y: 1.12, font: { color: "#ccc" } },
            grid: { rows: 1, columns: 2, pattern: "independent" },
            xaxis: { domain: [0, 0.48], gridcolor: "rgba(255,255,255,0.05)" },
            yaxis: { gridcolor: "rgba(255,255,255,0.05)" },
            xaxis2: { domain: [0.52, 1], gridcolor: "rgba(255,255,255,0.05)" },
            yaxis2: { gridcolor: "rgba(255,255,255,0.05)" },
            annotations: [
                { text: "ç°è´§", x: 0.24, y: 1.05, xref: "paper", yref: "paper", showarrow: false, font: { color: "#aaa", size: 14 } },
                { text: "åˆçº¦", x: 0.76, y: 1.05, xref: "paper", yref: "paper", showarrow: false, font: { color: "#aaa", size: 14 } },
            ],
        },
    };
}

function createVolumeChart(spotData, futuresData) {
    const spotVolumes = Object.entries(spotData).map(([name, tickers]) => ({
        name, volume: tickers.reduce((sum, t) => sum + t.volume, 0)
    }));
    const futuresVolumes = Object.entries(futuresData).map(([name, tickers]) => ({
        name, volume: tickers.reduce((sum, t) => sum + t.volume, 0)
    }));
    
    return {
        data: [
            {
                labels: spotVolumes.map(d => d.name), values: spotVolumes.map(d => d.volume),
                type: "pie", hole: 0.4, marker: { colors: spotVolumes.map(d => COLORS[d.name]) },
                domain: { x: [0, 0.45] }, textinfo: "label+percent", textfont: { color: "#fff" },
            },
            {
                labels: futuresVolumes.map(d => d.name), values: futuresVolumes.map(d => d.volume),
                type: "pie", hole: 0.4, marker: { colors: futuresVolumes.map(d => COLORS[d.name]) },
                domain: { x: [0.55, 1] }, textinfo: "label+percent", textfont: { color: "#fff" },
            }
        ],
        layout: {
            title: { text: "24h æˆäº¤é¢å æ¯”", font: { color: "#fff" } },
            height: 400, paper_bgcolor: "rgba(0,0,0,0)", font: { color: "#888" }, showlegend: false,
            annotations: [
                { text: "ç°è´§", x: 0.18, y: 0.5, font: { size: 16, color: "#aaa" }, showarrow: false },
                { text: "åˆçº¦", x: 0.82, y: 0.5, font: { size: 16, color: "#aaa" }, showarrow: false },
            ],
        },
    };
}

function create7DayVolumeChart(klineData) {
    const traces = [];
    const colors = { "BTC": "#F7931A", "ETH": "#627EEA", "SOL": "#00FFA3" };
    
    for (const [symbol, exchanges] of Object.entries(klineData)) {
        for (const [exchange, data] of Object.entries(exchanges)) {
            if (data.length > 0) {
                traces.push({
                    name: `${symbol} (${exchange})`,
                    x: data.map(d => d.date),
                    y: data.map(d => d.volume / 1e9),
                    type: "scatter",
                    mode: "lines+markers",
                    line: { width: 2 },
                    marker: { size: 6 },
                });
            }
        }
    }
    
    return {
        data: traces,
        layout: {
            title: { text: "7 å¤©æˆäº¤é¢è¶‹åŠ¿ï¼ˆåˆçº¦ï¼Œå•ä½ï¼šB USDTï¼‰", font: { color: "#fff" } },
            height: 400,
            paper_bgcolor: "rgba(0,0,0,0)", plot_bgcolor: "rgba(255,255,255,0.02)",
            font: { color: "#888" },
            xaxis: { gridcolor: "rgba(255,255,255,0.05)" },
            yaxis: { gridcolor: "rgba(255,255,255,0.05)", title: "æˆäº¤é¢ (B)" },
            legend: { font: { color: "#ccc" } },
        },
    };
}

function createDepthTable(depthData) {
    let html = `
        <div class="section-title">äº¤æ˜“æ·±åº¦æŒ‡æ ‡ï¼ˆåˆçº¦ï¼‰</div>
        <div class="chart-container">
            <table class="depth-table">
                <thead>
                    <tr>
                        <th>å¸ç§</th>
                        <th>äº¤æ˜“æ‰€</th>
                        <th>Bid-Ask Spread (bps)</th>
                        <th>Â±2% æ·±åº¦ (USDT)</th>
                        <th>Top10 æ¡£ (USDT)</th>
                        <th>è¯„çº§</th>
                    </tr>
                </thead>
                <tbody>
    `;
    
    for (const [symbol, exchanges] of Object.entries(depthData)) {
        for (const [exchange, metrics] of Object.entries(exchanges)) {
            const rating = metrics.spread < 5 ? "ä¼˜ç§€" : metrics.spread < 20 ? "è‰¯å¥½" : "ä¸€èˆ¬";
            const ratingClass = metrics.spread < 5 ? "rating-good" : metrics.spread < 20 ? "rating-ok" : "rating-bad";
            html += `
                <tr>
                    <td><strong>${symbol}</strong></td>
                    <td>${exchange}</td>
                    <td>${metrics.spread}</td>
                    <td>${formatVolume(metrics.depth2pct)}</td>
                    <td>${formatVolume(metrics.top10)}</td>
                    <td class="${ratingClass}">${rating}</td>
                </tr>
            `;
        }
    }
    
    html += `</tbody></table></div>`;
    return html;
}

// ========== ä¸»å‡½æ•° ==========

let isLoading = false;

async function refreshData() {
    if (isLoading) return;
    isLoading = true;
    
    const btn = document.querySelector(".refresh-btn");
    btn.disabled = true;
    btn.textContent = "â³ åŠ è½½ä¸­...";
    
    document.getElementById("stats-container").innerHTML = `
        <div class="loading">
            <div class="loading-spinner"></div>
            <p style="margin-top: 15px;">æ­£åœ¨è·å–æœ€æ–°æ•°æ®...</p>
        </div>
    `;
    document.getElementById("charts-container").innerHTML = "";
    
    try {
        // å¹¶è¡Œè·å–åŸºç¡€æ•°æ®
        const [binanceSpot, binanceFutures, okxSpot, okxSwap, bitmartSpot, bitmartFutures, hlSpot, hlPerps] = await Promise.all([
            fetchBinanceSpot(), fetchBinanceFutures(), fetchOKXSpot(), fetchOKXSwap(),
            fetchBitMartSpot(), fetchBitMartFutures(), fetchHyperliquidSpot(), fetchHyperliquidPerps(),
        ]);
        
        const spotData = { Binance: binanceSpot, OKX: okxSpot, BitMart: bitmartSpot, Hyperliquid: hlSpot };
        const futuresData = { Binance: binanceFutures, OKX: okxSwap, BitMart: bitmartFutures, Hyperliquid: hlPerps };
        
        // æ›´æ–°ç»Ÿè®¡å¡ç‰‡
        document.getElementById("stats-container").innerHTML = `
            <div class="stats-grid">
                ${Object.entries(spotData).map(([name, tickers]) => `
                    <div class="stat-card ${name.toLowerCase()}">
                        <h3>${name} ç°è´§</h3>
                        <div class="value">${tickers.length}</div>
                        <div class="sub">å¸ç§æ•°é‡</div>
                    </div>
                `).join("")}
                ${Object.entries(futuresData).map(([name, tickers]) => `
                    <div class="stat-card ${name.toLowerCase()}">
                        <h3>${name} åˆçº¦</h3>
                        <div class="value">${tickers.length}</div>
                        <div class="sub">å¸ç§æ•°é‡</div>
                    </div>
                `).join("")}
            </div>
        `;
        
        // ç”ŸæˆåŸºç¡€å›¾è¡¨
        const charts = [
            createCoinCountChart(spotData, futuresData),
            createTierChart(spotData, futuresData),
            createVolumeChart(spotData, futuresData),
        ];
        
        let chartsHtml = charts.map((_, i) => `<div class="chart-container"><div id="chart_${i}"></div></div>`).join("");
        
        // è·å– 7 å¤© K çº¿æ•°æ®
        const symbols = ["BTC", "ETH", "SOL"];
        const klineData = {};
        for (const symbol of symbols) {
            klineData[symbol] = {
                Binance: await fetch7DayKlines(symbol, "Binance"),
                OKX: await fetch7DayKlines(symbol, "OKX"),
            };
        }
        
        // æ·»åŠ  7 å¤©æˆäº¤é¢å›¾è¡¨
        const klineChart = create7DayVolumeChart(klineData);
        chartsHtml += `<div class="chart-container"><div id="chart_7d"></div></div>`;
        
        // è·å–æ·±åº¦æ•°æ®
        const depthData = {};
        for (const symbol of symbols) {
            depthData[symbol] = {
                Binance: await fetchDepth(symbol, "Binance"),
                OKX: await fetchDepth(symbol, "OKX"),
                Hyperliquid: await fetchDepth(symbol, "Hyperliquid"),
            };
        }
        
        // æ·»åŠ æ·±åº¦è¡¨æ ¼
        chartsHtml += createDepthTable(depthData);
        
        document.getElementById("charts-container").innerHTML = chartsHtml;
        
        // æ¸²æŸ“å›¾è¡¨
        charts.forEach((chart, i) => {
            Plotly.newPlot(`chart_${i}`, chart.data, chart.layout, { responsive: true });
        });
        Plotly.newPlot("chart_7d", klineChart.data, klineChart.layout, { responsive: true });
        
        document.getElementById("timestamp").textContent = `æ•°æ®æ›´æ–°æ—¶é—´: ${new Date().toLocaleString("zh-CN")}`;
        
    } catch (e) {
        console.error("Error:", e);
        document.getElementById("stats-container").innerHTML = `
            <div style="color:#ff6b6b;padding:20px;text-align:center;">æ•°æ®åŠ è½½å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•</div>
        `;
    }
    
    btn.disabled = false;
    btn.textContent = "ğŸ”„ åˆ·æ–°æ•°æ®";
    isLoading = false;
}

document.addEventListener("DOMContentLoaded", refreshData);
</script>
</body>
</html>
